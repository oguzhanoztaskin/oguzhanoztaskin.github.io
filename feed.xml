<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://oguzhanstech.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://oguzhanstech.com/" rel="alternate" type="text/html" /><updated>2025-11-16T07:39:40+00:00</updated><id>https://oguzhanstech.com/feed.xml</id><title type="html">Oguzhan’s Tech</title><subtitle>A blog about my hustles, which are mostly about cryptography, cyber security, or software projects.</subtitle><entry><title type="html">KZG Batching in Plonk</title><link href="https://oguzhanstech.com/2025/11/07/kzg-batching-in-plonk.html" rel="alternate" type="text/html" title="KZG Batching in Plonk" /><published>2025-11-07T00:00:00+00:00</published><updated>2025-11-07T00:00:00+00:00</updated><id>https://oguzhanstech.com/2025/11/07/kzg-batching-in-plonk</id><content type="html" xml:base="https://oguzhanstech.com/2025/11/07/kzg-batching-in-plonk.html"><![CDATA[<p>In my last post, we explored the <a href="/2025/10/13/kzg-poly-commit-scheme.html">KZG Polynomial Commitment Scheme</a>, a powerful tool for proving that a secret polynomial $p(X)$ evaluates to a certain value $y$ at a public point $z$. That is, we can prove the claim $p(z) = y$.</p>

<p>This is a fantastic building block, but in larger systems like Plonk <a class="citation" href="#gabizon2019plonk">(Gabizon et al., 2019)</a>, we often need to prove more than just one evaluation. We need to prove that a polynomial equation holds true over an entire <em>set</em> of points. For example, we might need to prove $P(x) = 0$ for every single $x$ in a domain $H$.</p>

<p>How could we do this? We could run a separate KZG proof for every point in $H$, but if $H$ has thousands of elements, our proof would become enormous and the verification process painfully slow. We need a more efficient way to bundle all these checks into one.</p>

<p>The answer we are looking for is the use of KZG batching. Plonk utilizes a form of batching that’s well-suited for its constraint system, and in this post we are going to take a closer look into that approach.</p>

<p>Alternative posts that I recommend are the original paper’s Batch Opening paragraph <a class="citation" href="#kate2010constant">(Kate et al., 2010)</a> and <a href="https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html">Dankrad Feist’s blog post’s Multiproof section</a>.</p>

<p><strong>Disclaimer:</strong> These are my personal notes and understanding of the topic. They may contain errors or oversimplifications. I don’t claim to provide absolute truth - rather, I invite discussion and corrections. If you spot any mistakes or have insights to share, please reach out!</p>

<h2 id="preliminaries">Preliminaries</h2>

<p>Some definitions and notes we’ll be using:</p>

<ul>
  <li>
    <p><strong>Polynomial Degree</strong>: $f \in \mathbb{F}_{&lt; n}[X]$ means $f$ is a polynomial with degree less than $n$.</p>
  </li>
  <li>
    <p><strong>Commitment Notation</strong>: The commitment of a polynomial $f(X)$ is represented as $[f(x)]_1$. Unless specified, commitments are in the first group, $\mathbb{G}_1$.</p>
  </li>
  <li><strong>Additive Homomorphism</strong>: Our commitment scheme is additively homomorphic. For polynomials $f(X)$, $g(X)$ and a scalar $c$:
    <ul>
      <li><strong>Addition</strong>: $[f(x)] + [g(x)] = [f(x) + g(x)]$</li>
      <li><strong>Scalar Multiplication</strong>: $c[f(x)] = [c \cdot f(x)]$</li>
    </ul>
  </li>
  <li>
    <p><strong>Pairings</strong>: $e([f]_1, [g]_2)$ is our bilinear pairing function.</p>
  </li>
  <li>
    <p><strong>Vanishing Polynomial</strong>: For a set of points $S = {s_0, s_1, \dots, s_{k-1}}$, the vanishing polynomial is defined as:
\(Z_S(X) \coloneqq \prod_{i=0}^{k-1} (X - s_i)\)
This polynomial has a crucial property: it evaluates to $0$ for every single point in the set $S$.</p>
  </li>
  <li><strong>Prerequisites</strong>: I’ll assume you’re familiar with the concepts from my <a href="/2025/10/13/kzg-poly-commit-scheme.html">previous post on KZG</a>.</li>
</ul>

<h2 id="the-core-idea-from-many-checks-to-one">The Core Idea: From Many Checks to One</h2>

<p>Let’s say we have a claim: a secret polynomial $P(X)$ is equal to $0$ on every point in a public domain $H$.</p>

<p>The key insight is this: a polynomial $P(X)$ is zero at every point $h$ in $H$ <em>if and only if</em> it is divisible by the vanishing polynomial $Z_H(X)$.</p>

<p>Why is this true? From basic algebra, we know that if $P(h) = 0$, then $(X-h)$ must be a factor of $P(X)$. If this is true for <em>all</em> $h$ in $H$, then the product of all those factors, which is exactly our vanishing polynomial $Z_H(X)$, must also be a factor of $P(X)$.</p>

<p>This means that if our claim is true, the division must be exact. We can define a quotient polynomial $Q(X)$ like this:</p>

\[Q(X) \coloneqq \dfrac{P(X)}{Z_H(X)}\]

<p>This single equation, $P(X) = Q(X) \cdot Z_H(X)$, is equivalent to the $n$ individual checks we started with! Now, our task has been reduced to proving that this new polynomial identity is true.</p>

<h2 id="the-protocol">The Protocol</h2>

<p>How can a prover convince a verifier of this identity? They can’t just send the polynomial $Q(X)$, because $P(X)$ is secret, so $Q(X)$ must also be secret.</p>

<p>Instead, we can use polynomial commitments and a random challenge point, very similar to what we did in KZG. By the Schwartz-Zippel lemma, if two polynomials are equal, they will evaluate to the same value at a random point $\zeta$ with very high probability.</p>

<p>So, the verifier will check the identity $P(\zeta) = Q(\zeta) \cdot Z_H(\zeta)$.</p>

<p><strong>Claim:</strong> A secret polynomial $P(X)$ is $0$ on the public domain $H$.</p>

<p><strong>Common Inputs:</strong> The vanishing polynomial for the domain $H$, which is $Z_H(X)$.</p>

<p><strong>Prover Inputs:</strong> The secret polynomial $P(X)$.</p>

<p><strong>Protocol:</strong></p>

<ol>
  <li>
    <p><strong>Compute the Quotient Polynomial</strong>:
The prover computes the quotient $Q(X) = \dfrac{P(X)}{Z_H(X)}$. If the claim is false, this division will have a non-zero remainder, and the protocol will fail.</p>
  </li>
  <li>
    <p><strong>Commit to Polynomials</strong>:
The prover commits to the secret polynomials $P(X)$ and $Q(X)$ and sends the commitments $[P(x)]_1$ and $[Q(x)]_1$ to the verifier.</p>
  </li>
  <li>
    <p><strong>Get Random Challenge</strong>:
The verifier generates a random challenge scalar $\zeta$ (zeta) and sends it to the prover. (In a real system, this would be derived from the transcript using Fiat-Shamir).</p>
  </li>
  <li>
    <p><strong>Prove the Evaluation</strong>:
The prover and verifier now want to check the identity $P(\zeta) - Q(\zeta) \cdot Z_H(\zeta) = 0$. This is an evaluation proof! The prover needs to prove that the remainder polynomial $R(X) \coloneqq P(X) - Z_H(\zeta) \cdot Q(X)$ evaluates to $0$ at $X = \zeta$.</p>

    <p>Notice a subtle but important detail here. In the expression for $R(X)$, we use $Z_H(\zeta)$. This is the <em>evaluation</em> of the public polynomial $Z_H(X)$ at the point $\zeta$, which is just a scalar value. We do this because we can’t multiply two commitments together, but we <em>can</em> multiply a commitment by a scalar. Later on, we need to evaluate the entire expression at $\zeta$, so putting $Z_H(X)$’s evaluation here does not cause trouble.</p>

    <p>To prove $R(\zeta) = 0$, the prover computes the KZG witness polynomial:</p>

\[W_\zeta(X) \coloneqq \dfrac{R(X)}{X-\zeta} = \dfrac{P(X) - Z_H(\zeta) \cdot Q(X)}{X-\zeta}\]

    <p>The prover commits to this witness, $[W_\zeta(x)]_1$, and sends it to the verifier.</p>
  </li>
  <li>
    <p><strong>Verifier Check</strong>:
The verifier now has all the pieces: $[P(x)]_ 1$, $[Q(x)]_ 1$, and $[W_\zeta(x)]_ 1$. They can perform the final check using a single pairing equation. The verifier wants to confirm that</p>

\[\begin{align}
W_\zeta(X) \cdot (X - \zeta) &amp;- R(X) &amp;= 0 \notag \\
W_\zeta(X) \cdot (X - \zeta) &amp;- (P(X) - Z_H(\zeta)\cdot Q(X)) &amp;= 0 \notag
\end{align}\]

    <p>and for that it uses the committed values in the following check:</p>

\[e([W_\zeta(x)]_1, [x]_2 - \zeta[1]_2) \stackrel{?}{=} e([P(x)]_1 - Z_H(\zeta)[Q(x)]_1, [1]_2)\]

    <p>Notice that this equation forces the prover to use the committed polynomial $P(X)$, the provided quotient $Q(X)$ to be the true division, and hence the right hand side effectively calculates $[R(x)]_1$.</p>

    <p>Then, the left hand side is designed so that it only holds if $R(X)$ is $0$ at $\zeta$, a random point. As we explained before, this implies the remainder polynomial is exactly $0$ everywhere, that is the division is exact, and therefore $P(X)$ is $0$ on $H$.</p>
  </li>
</ol>

<h2 id="conclusion">Conclusion</h2>

<p>We’ve just learned a powerful and efficient technique. We’ve managed to take a claim that required $n$ separate checks ($P(x) = 0$ for all $x$ in $H$) and compress it into a single, compact proof that requires only a few commitments and one pairing check.</p>

<h2 id="references">References</h2>

<ol class="bibliography"><li><span id="gabizon2019plonk">Gabizon, A., Williamson, Z. J., &amp; Ciobotaru, O. (2019). Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. <i>Cryptology EPrint Archive</i>.</span></li>
<li><span id="kate2010constant">Kate, A., Zaverucha, G. M., &amp; Goldberg, I. (2010). Constant-size commitments to polynomials and their applications. <i>International Conference on the Theory and Application of Cryptology and Information Security</i>, 177–194.</span></li></ol>]]></content><author><name></name></author><category term="cryptography" /><category term="zkp" /><category term="plonk" /><category term="polynomials" /><category term="kzg" /><summary type="html"><![CDATA[In my last post, we explored the KZG Polynomial Commitment Scheme, a powerful tool for proving that a secret polynomial $p(X)$ evaluates to a certain value $y$ at a public point $z$. That is, we can prove the claim $p(z) = y$.]]></summary></entry><entry><title type="html">KZG Polynomial Commitment Scheme</title><link href="https://oguzhanstech.com/2025/10/13/kzg-poly-commit-scheme.html" rel="alternate" type="text/html" title="KZG Polynomial Commitment Scheme" /><published>2025-10-13T00:00:00+00:00</published><updated>2025-10-13T00:00:00+00:00</updated><id>https://oguzhanstech.com/2025/10/13/kzg-poly-commit-scheme</id><content type="html" xml:base="https://oguzhanstech.com/2025/10/13/kzg-poly-commit-scheme.html"><![CDATA[<p>KZG polynomial commitment scheme <a class="citation" href="#kate2010constant">(Kate et al., 2010)</a> is a fundamental building block for many zero-knowledge proof systems, including Plonk <a class="citation" href="#gabizon2019plonk">(Gabizon et al., 2019)</a>. In this post, I’ll explain how KZG works and provide the groundwork needed for understanding more complex protocols.</p>

<p>My goal is making these posts implementation oriented - not too abstract. However, some used concepts will not be described in full, this will be more like <em>some notes on cryptography</em>.</p>

<p>For more complete, reliable, and more reviewed text you may refer to <a href="https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html">Dankrad Feist’s blog</a> or to the original paper <a class="citation" href="#kate2010constant">(Kate et al., 2010)</a>.</p>

<p><strong>Disclaimer:</strong> These are my personal notes and understanding of the topic. They may contain errors or oversimplifications. I don’t claim to provide absolute truth - rather, I invite discussion and corrections. If you spot any mistakes or have insights to share, please reach out!</p>

<h2 id="preliminaries">Preliminaries</h2>

<p>Some definitions and notes:</p>

<p><strong>Polynomial Degree</strong>: $f \in \mathbb{F}_{&lt; n}[X]$ means $f$ is a polynomial with degree less than $n$.</p>

<p><strong>Commitment Notation</strong>: The commitment of polynomial $f(X)$ is represented as $[f(x)]_1$ if it is in the first group, and $[f(x)]_2$ if it is in the second group. If no subscript is provided, it is a commitment in the first group.</p>

<p><strong>Additive Homomorphism</strong>: The commitment scheme allows for addition and scalar multiplication. This means that for polynomials $f(X)$ and $g(X)$ and a scalar $c$:</p>
<ul>
  <li><strong>Addition</strong>: $[f(x)] + [g(x)] = [f(x) + g(x)]$</li>
  <li><strong>Scalar Multiplication</strong>: $c[f(x)] = [c \cdot f(x)]$</li>
</ul>

<p><strong>Pairings</strong>: $e([f]_1, [g]_2)$ takes two arguments and is bilinear:</p>

\[e(a[f]_1, b[g]_2) = e([f]_1, ab[g]_2) = e(ab[f]_1, [g]_2) = e([f]_1, [g]_2)^{ab}\]

<h2 id="what-is-kzg">What is KZG?</h2>

<p>KZG is the polynomial commitment scheme (PCS) used by Plonk, and the PCS I chose to use for my work.
A polynomial commitment scheme is a protocol that allows the prover to commit to a polynomial, and then in zero-knowledge prove its evaluation at a given point.</p>

<p>The high level idea of KZG is that</p>

<ul>
  <li>If a polynomial $p(X)$ passes through $(x_0, y_0)$, then the polynomial $p’(X) \coloneqq p(X)-y_0$ is $0$ at $X=x_0$.</li>
  <li>Then $p’(X)$ has a root at $X=x_0$. That is, $X-x_0$ is a factor of it and if we divide $p’(X)$ by this value, the division must be exact.</li>
  <li>If we can prove that the division is exact, for example by multiplying the quotient with the divisor and checking if the result is the same as the expected dividend, we would be proving the polynomial evaluation.</li>
  <li>That multiplication can be proven using elliptic curves and pairings. That is what KZG does.</li>
</ul>

<p>In the following section, I explain this by showing each step.</p>

<h2 id="the-protocol">The Protocol</h2>

<p><strong>Claim:</strong> $p(X) \in \mathbb{F}_{&lt; n}[X]$ is a private polynomial and it passes through the public point $(x_0, y_0)$.</p>

<p><strong>Setup:</strong> Trusted setup provides the commitments $[1]_1, [x]_1, [x^2]_1, \dots, [x^{n-1}]_1$ and $[1]_2, [x]_2$. This is called the Structured Reference String, or SRS for short.</p>

<p>Here, $x$ is a toxic variable that no one should know. It is required for the generation of SRS, but then it must be destroyed. Because if someone knows $x$, they can make false proofs, i.e. showing a polynomial passes through a point when it actually does not.</p>

<p><strong>Common Inputs:</strong> $(x_0, y_0) \in \mathbb{F}^2$</p>

<p><strong>Prover Inputs:</strong> $p(X) \in \mathbb{F}_ {&lt; n}[X]$, written as $p(X) = c_ 0 + c_ 1 X + c_ 2 X^2 + \dots + c_{n-1} X^{n-1}$</p>

<p><strong>Protocol:</strong></p>

<ol>
  <li>
    <p><strong>Compute the Quotient Polynomial</strong>:</p>

    <p>Prover computes the quotient polynomial $q(X) \coloneqq \dfrac{p(X) - y_0}{X-x_0}$</p>

    <p>Notice that for this to be true, there should be no remainder polynomial. This is true if the claim $p(x_0) \stackrel{?}{=} y_0$ is true. To see this, assume the claim. Then observe the polynomial $p(X) - y_0$ has a root at $X=x_0$:</p>

\[\begin{align}
 (p(X) - y_0)\mid_{X=x_0} &amp;= p(x_0) - y_0 \notag \\
 p(x_0) - y_0 &amp;= y_0 - y_0 = 0 \notag \\
 \end{align}\]

    <p>Therefore, $X-x_0$ is a factor of it and thus the division is exact, i.e. the remainder polynomial of the division is $0$.</p>
  </li>
  <li>
    <p><strong>Commit to Polynomials</strong>:</p>

    <p>Prover commits to $p(X), q(X)$, that is using SRS it computes</p>

\[\begin{align}
 [p(x)]_1 &amp;= c_0[1]_1 + c_1[x]_1 + \dots + c_{n-1}[x^{n-1}]_1 \notag \\
 [q(x)]_1 &amp;= c^q_0[1]_1 + c^q_1[x]_1 + \dots + c^q_{m-1}[x^{m-1}]_1 \notag \\
 \end{align}\]

    <p>This computation is possible due to the following facts: commitments to the powers of $x$, i.e. $[x^j]_1$, are present in the SRS, and the commitment scheme is additively homomorphic. Therefore, we can compute the scalar multiplications, e.g. $c_1[x]_1$, and then sum these scaled commitments together. This is called <strong>multiscalar multiplication (MSM)</strong>.</p>

\[\begin{align}
 [p(x)]_1 = \sum_{i=0}^{n-1} c_i[x^i]_1 \tag{$n-1$ is the degree of $p(X)$}
 \end{align}\]

    <p>Notice that the commitment is just evaluating the polynomial at $X=x$, the toxic waste, and taking that to the elliptic curve.</p>
  </li>
  <li>
    <p><strong>Send Commitments</strong>:</p>

    <p>Prover sends $[p(x)]_1, [q(x)]_1$ to the verifier.</p>
  </li>
  <li>
    <p><strong>Verifier Check</strong>:</p>

    <p>Verifier checks the equation:</p>

\[\begin{align}
 e([q(x)]_1, [x]_2 + (-x_0)[1]_2) &amp;\stackrel{?}{=} e([p(x)]_1 + (-y_0)[1]_1,[1]_2) \notag \\
 \end{align}\]

    <p>If the check passes, the verifier accepts the claim $p(x_0) \stackrel{?}{=} y_0$.</p>
  </li>
</ol>

<h2 id="understanding-the-pairing-equation">Understanding the Pairing Equation</h2>

<p>The pairing allows us to represent the multiplication of two commitments, the divisor and the quotient as a target group element (the output of the pairing). That is, we reconstructed the dividend as a target group element on the left hand side. Then, we put the expected dividend on the right hand side. Finally, we checked if the two pairings are equivalent.</p>

<p>The important fact here is that we could not simply multiply the quotient and the divisor commitments because we only have addition. The pairing gave us a workaround for this: representing that multiplication as its target group’s element.</p>

<p>In other words, the pairing helped us revert the division to a multiplication and check its result.</p>

<p><strong>Reading a pairing equation:</strong> Apply the following transformations:</p>

<ul>
  <li>Every commitment is an evaluation at $x$, the toxic variable. Revert it by replacing $x$ with $X$.</li>
  <li>$e(a, b)$ is just $a\cdot b$.</li>
</ul>

<p>Therefore, if we apply them to the pairing equation, we get</p>

\[\begin{align}
q(X)\cdot(X-x_0) \stackrel{?}{=} p(X) - y_0 \notag
\end{align}\]

<p>This is <em>a conceptual transformation</em> I use for ease of reading. Some information is lost during this transformation and hence it does not perfectly represent the pairing. Alternatively, Dankrad <a class="citation" href="#feist2020kate">(Feist, 2020)</a> writes this pairing in the target group:</p>

\[\begin{align}
[q(x)\cdot(x-x_0)]_T \stackrel{?}{=} [p(x) - y_0]_T \notag
\end{align}\]

<h2 id="conclusion">Conclusion</h2>

<p>We have seen fundamental concepts like how to compute a commitment to a polynomial, how additive homomorphism works, how pairings work, and how KZG’s protocol is designed. We will build on these in the later posts where we work on more complicated ideas.</p>

<h2 id="references">References</h2>

<ol class="bibliography"><li><span id="kate2010constant">Kate, A., Zaverucha, G. M., &amp; Goldberg, I. (2010). Constant-size commitments to polynomials and their applications. <i>International Conference on the Theory and Application of Cryptology and Information Security</i>, 177–194.</span></li>
<li><span id="gabizon2019plonk">Gabizon, A., Williamson, Z. J., &amp; Ciobotaru, O. (2019). Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. <i>Cryptology EPrint Archive</i>.</span></li>
<li><span id="feist2020kate">Feist, D. (2020). <i>KZG polynomial commitments</i>. Dankrad Feist’s blog. https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html</span></li></ol>]]></content><author><name></name></author><category term="cryptography" /><category term="zkp" /><category term="kzg" /><category term="commitment schemes" /><summary type="html"><![CDATA[KZG polynomial commitment scheme (Kate et al., 2010) is a fundamental building block for many zero-knowledge proof systems, including Plonk (Gabizon et al., 2019). In this post, I’ll explain how KZG works and provide the groundwork needed for understanding more complex protocols.]]></summary></entry><entry><title type="html">SSL Pinning Bypass: Network Security Config</title><link href="https://oguzhanstech.com/2025/08/25/ssl-pinning-bypass-network-security-config.html" rel="alternate" type="text/html" title="SSL Pinning Bypass: Network Security Config" /><published>2025-08-25T00:00:00+00:00</published><updated>2025-08-25T00:00:00+00:00</updated><id>https://oguzhanstech.com/2025/08/25/ssl-pinning-bypass-network-security-config</id><content type="html" xml:base="https://oguzhanstech.com/2025/08/25/ssl-pinning-bypass-network-security-config.html"><![CDATA[<p>In this post, I will talk about how I bypassed the simplest SSL pinning method: <a href="https://developer.android.com/privacy-and-security/security-config">Network Security Config</a> via APK resource editing. I will also explain my setup.</p>

<p>I assume you know how to use the tools mitmproxy, an Android proxy client, apktool, adb and do not detail it here.</p>

<h2 id="why-do-this-at-all">Why Do This At All?</h2>
<p>SSL Pinning protects your apps their network protocols revealed. Though it is a client side protection and you should focus on server side for the most part, it is still relevant: This will slow down anyone that wants to learn your API, bot it or cheat it.</p>

<p>Studying SSL pinning bypasses is both a fun technical challenge and a way to better understand app defenses. My personal goal here is to observe app traffic directly in mitmproxy, while learning how different protections work.</p>

<h2 id="bypassing-network-security-config">Bypassing Network Security Config</h2>
<p>Bypassing Network Security Config was simple:</p>
<ul>
  <li>Decompile the APK with <a href="https://apktool.org/">apktool</a></li>
  <li>Find the name of the config from <code class="language-plaintext highlighter-rouge">AndroidManifest.xml</code> in the <code class="language-plaintext highlighter-rouge">application</code> tag as the value of <code class="language-plaintext highlighter-rouge">android:networkSecurityConfig</code>, usually it is <code class="language-plaintext highlighter-rouge">res/xml/network_security_config.xml</code></li>
  <li>then set it to be:</li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="nt">&lt;network-security-config&gt;</span>
    <span class="nt">&lt;base-config</span> <span class="na">cleartextTrafficPermitted=</span><span class="s">"false"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;trust-anchors&gt;</span>
            <span class="nt">&lt;certificates</span> <span class="na">src=</span><span class="s">"system"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;certificates</span> <span class="na">src=</span><span class="s">"user"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/trust-anchors&gt;</span>
    <span class="nt">&lt;/base-config&gt;</span>
<span class="nt">&lt;/network-security-config&gt;</span>
</code></pre></div></div>
<p>This will make it trust installed certificates - including the <a href="https://www.mitmproxy.org/">mitmproxy</a>’s certificate if installed. Also if there was any certificate pinned this way, we effectively erased it.<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup></p>

<p>We can see that the default setting is to only trust system certificates and no cleartext traffic, for API level 28 and higher according to <a href="https://developer.android.com/privacy-and-security/security-config">here</a>. Therefore, adding user certificates as a trust anchor is necessary.</p>

<p>After this, we can build and sign the app and install it on the target device. Next, we need to put the app’s network traffic through mitmproxy to observe it.</p>

<h2 id="setting-up-the-proxy">Setting up the Proxy</h2>
<p>We need to run mitmproxy on the host and configure the target device to use it. However, the host and the target device possibly lie on different networks and cannot see each other. We cannot make the target device connect to mitmproxy then. I assume a USB connection to the target device is present, so I will use adb to make the devices connect. In the next subsection I explain how.</p>

<h3 id="a-note-on-adb-port-forwarding">A Note on ADB Port Forwarding</h3>
<p>ADB has two useful commands for port forwarding, the second one is something I wish I had seen sooner<sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>. Here I detail them:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>adb forward tcp:7777 tcp:8888
</code></pre></div></div>
<p>This forwards the port 7777 on the host (i.e. the device running adb, your computer) to the port 8888 on the target device (i.e. your mobile which is connected using a USB cable maybe). What this means is, any connection to port 7777 on your host will be directed to the port 8888 on your target device. For example, if you have an HTTP server listening on port 8888 on your target device, you can access it on your computer via <code class="language-plaintext highlighter-rouge">localhost:7777</code>.</p>

<p>The other command I wish I had learned sooner is the <code class="language-plaintext highlighter-rouge">adb reverse</code> command.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>adb reverse tcp:3333 tcp:4444
</code></pre></div></div>
<p>This does the opposite of the <code class="language-plaintext highlighter-rouge">adb forward</code> command as the name suggests: The port 3333 on the target device is forwarded to the port 4444 on the host device. That is, if you host the HTTP server on your host at 4444, you can access it on your mobile via <code class="language-plaintext highlighter-rouge">localhost:3333</code>.</p>

<p>Mitmproxy listens at 8080 by default, so we are going to do</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>adb reverse tcp:8080 tcp:8080
</code></pre></div></div>
<p>Now we can run a http proxy app on the target device and connect it to <code class="language-plaintext highlighter-rouge">127.0.0.1:8080</code> so that it connects to the mitmproxy. Then you should be able to see the network traffic.</p>

<h2 id="conclusion">Conclusion</h2>
<p>We saw how easy it is to bypass the Network Security Config. All we needed to do was decompile, change an XML file, and recompile. To defend against modification of the APK, one can harden their APK using special tools that make apktool fail.</p>

<p><strong>Disclaimer:</strong> This post is intended solely for educational and research purposes. The techniques described here should only be applied to applications you own or have explicit permission to analyze. Reverse engineering, modifying, or intercepting traffic of third-party apps without consent may violate their terms of service and applicable laws. I do not encourage or condone using these methods against third-party apps without permission.</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>Actually I used a script for this and it did not remove the domain-configs and pin-sets, it just added this base-config after them. I thought bypass would fail because pin-set tags would override the base-config, yet it works. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>https://android.googlesource.com/platform/packages/modules/adb/+/refs/heads/master/docs/user/adb.1.md <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="android" /><category term="security" /><category term="ssl-pinning" /><category term="mitmproxy" /><summary type="html"><![CDATA[In this post, I will talk about how I bypassed the simplest SSL pinning method: Network Security Config via APK resource editing. I will also explain my setup.]]></summary></entry><entry><title type="html">SSL Pinning Bypass: SSLContext</title><link href="https://oguzhanstech.com/2025/08/25/ssl-pinning-bypass-sslcontext.html" rel="alternate" type="text/html" title="SSL Pinning Bypass: SSLContext" /><published>2025-08-25T00:00:00+00:00</published><updated>2025-08-25T00:00:00+00:00</updated><id>https://oguzhanstech.com/2025/08/25/ssl-pinning-bypass-sslcontext</id><content type="html" xml:base="https://oguzhanstech.com/2025/08/25/ssl-pinning-bypass-sslcontext.html"><![CDATA[<p>In this post, I will explain how to bypass SSL Pinning via <a href="https://developer.android.com/reference/javax/net/ssl/SSLContext">SSLContext</a> using <a href="https://frida.re/">Frida</a>.</p>

<p>As the injection method, I use dylib injection for the reasons I explain below.</p>

<h2 id="split-apks">Split APKs</h2>
<p>Nowadays most apps are split APKs, meaning that they are split into different parts: A main APK that contains .dex files and most resources, one for native libraries (config.arm64_v8a.apk), one for each language the app supports (config.en.apk), one for graphics (config.mdpi.apk) etc. Furthermore, sometimes apktool fails on decompiling/recompiling the main APK and in such cases dylib injection is useful. This is because we do not have to change main APK at all (just resign it with our key), we only have to inject the Frida gadget into a library which lies in <code class="language-plaintext highlighter-rouge">config.&lt;arch&gt;.apk</code>.</p>

<h2 id="injecting-frida-into-a-library">Injecting Frida into a library</h2>
<p>First, we decompile <code class="language-plaintext highlighter-rouge">config.&lt;arch&gt;.apk</code> that contains the libraries. Then we will find a library that is loaded first, like <code class="language-plaintext highlighter-rouge">libreact_render_core.so</code> or anything else that might work. Then we will use the following script to inject the Frida gadget <code class="language-plaintext highlighter-rouge">libfrida-gadget.so</code> into it.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">lief</span><span class="p">,</span> <span class="n">sys</span>

<span class="n">target</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span>
<span class="n">libnative</span> <span class="o">=</span> <span class="n">lief</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
<span class="n">libnative</span><span class="p">.</span><span class="nf">add_library</span><span class="p">(</span><span class="sh">"</span><span class="s">libfrida-gadget.so</span><span class="sh">"</span><span class="p">)</span>
<span class="n">libnative</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
</code></pre></div></div>
<p>This adds <code class="language-plaintext highlighter-rouge">libfrida-gadget.so</code> to the ELF’s dynamic section so that our gadget is loaded alongside the target library<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>. You can check this with the <code class="language-plaintext highlighter-rouge">readelf</code> command:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>readelf <span class="nt">-d</span> libreact_render_core.so 

Dynamic section at offset 0x22000 contains 43 entries:
  Tag        Type                         Name/Value
 0x00000001 <span class="o">(</span>NEEDED<span class="o">)</span>                     Shared library: <span class="o">[</span>libfrida.so]
 0x00000001 <span class="o">(</span>NEEDED<span class="o">)</span>                     Shared library: <span class="o">[</span>libjsi.so]
 0x00000001 <span class="o">(</span>NEEDED<span class="o">)</span>                     Shared library: <span class="o">[</span>liblogger.so]
 0x00000001 <span class="o">(</span>NEEDED<span class="o">)</span>                     Shared library: <span class="o">[</span>libreact_config.so]
...
</code></pre></div></div>
<p>This is explained in a much better detail at <a href="https://lief.re/doc/stable/tutorials/09_frida_lief.html">here</a>.</p>

<p>Once the Frida gadget works (the app freezes until I connect to it on startup), I ran the following command, <a href="/2025/08/25/ssl-pinning-bypass-network-security-config.html#a-note-on-adb-port-forwarding">explained more detailed here</a>:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>adb forward tcp:27042 tcp:27042
</code></pre></div></div>
<p>This forwards the port 27042 on my computer to the same port on my mobile, where Frida gadget listens by default. I can then connect to the Frida gadget via <code class="language-plaintext highlighter-rouge">frida -R gadget -l ssl.js</code> and let the script do the bypassing.</p>

<h3 id="frida---ssl-pinning-bypass-script">Frida - SSL Pinning Bypass Script</h3>
<p>The <code class="language-plaintext highlighter-rouge">ssl.js</code> I used above can be found <a href="https://codeshare.frida.re/@pcipolloni/universal-android-ssl-pinning-bypass-with-frida/">here</a>. This script does the following:</p>
<ul>
  <li>Get <code class="language-plaintext highlighter-rouge">javax.net.ssl.TrustManagerFactory</code> and use it to create a TrustManager for the certificate at <code class="language-plaintext highlighter-rouge">/data/local/tmp/cert-der.crt</code><sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup></li>
  <li>Hook <code class="language-plaintext highlighter-rouge">SSLContext.init</code> method so that all calls to it are intercepted.</li>
  <li>When <code class="language-plaintext highlighter-rouge">SSLContext.init</code> is called, instead of the provided TrustManager, use our own that carries mitmproxy’s certificate.
Once injected, the script logs its actions in real-time, so you can confirm whether the bypass worked.</li>
</ul>

<p>And that’s it. At this point I am supposed to be able to see the traffic. However I noticed while I can see some, there is still some traffic which I cannot as evident by mitmproxy’s logs. Then I realized there was another SSL pinning layer I hadn’t addressed: Network Security Config.</p>

<h2 id="conclusion">Conclusion</h2>
<p>In this post, I demonstrated a less known way of injecting Frida by modifying shared libraries, which avoids the common pitfalls of smali recompilation errors. Then we used a Frida script to hook <code class="language-plaintext highlighter-rouge">SSLContext.init</code> method. I have no practical defense solutions for this attack - Android does not seem to provide a way to see whether SSLContext is initialized with the intended trust manager or not. For a more general defense, detecting whether the gadget is present or not can be used, perhaps by listing the libraries.</p>

<p><strong>Disclaimer:</strong> This post is intended solely for educational and research purposes. The techniques described here should only be applied to applications you own or have explicit permission to analyze. Reverse engineering, modifying, or intercepting traffic of third-party apps without consent may violate their terms of service and applicable laws. I do not encourage or condone using these methods against third-party apps without permission.</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>Sometimes this method silently fails and I haven’t figured out why yet. Injecting the Frida gadget into another library often works. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>This will be the mitmproxy’s certificate and we will push it to the device with <code class="language-plaintext highlighter-rouge">adb push mitmproxy.cert /data/local/tmp/cert-der.crt</code>. This is a directory all apps can access and that’s why we are using it. You can find mitmproxy certificates on your computer at <code class="language-plaintext highlighter-rouge">~/.mitmproxy</code> or your mobile that uses mitmproxy as proxy at <code class="language-plaintext highlighter-rouge">http://mitm.it</code>. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="android" /><category term="security" /><category term="ssl-pinning" /><category term="frida" /><summary type="html"><![CDATA[In this post, I will explain how to bypass SSL Pinning via SSLContext using Frida.]]></summary></entry></feed>